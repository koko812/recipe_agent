# LEARNED.md

## レシピ検索ミニアプリ開発ログ

### アイデア
- AIエージェント風のアプリを作る練習として、まずはシンプルなレシピ検索アプリを構築することを目標にした。
- 最初はインメモリ（Pythonリスト）のダミーデータで検索を実装し、その後SQLiteに移行する方針を採用。
- Pydanticでリクエストやレスポンスを型定義することで、堅牢性とJSON変換の容易さを両立。
- 将来的には栄養価計算や材料ベースでの検索機能も拡張したいという構想を得た。

### 実装・試行錯誤の過程
1. **インメモリ実装**
   - `models.py` に `Ingredient`, `Recipe`, `SearchRequest` をPydanticで定義。
   - `app.py` にダミーレシピを用意し、`/search` エンドポイントを実装。
   - キーワードを空白区切りで分割し、タイトルや材料にすべて含まれているかでマッチ判定（AND検索）。
   - 変数名 `hay` は「needle in haystack」から来ており、検索対象の文字列を意味することを学んだ。

2. **FastAPI + Pydantic の挙動**
   - クライアントは `Content-Type: application/json` を必ず指定する必要がある。
   - サーバ側では `request.json` などを書かなくても、自動的にPydanticモデルにマッピングされる。
   - 型不一致やJSON不正時には自動で `422 Unprocessable Entity` エラーを返す仕組みを確認。

3. **SQLite 導入**
   - スキーマを定義して `recipes`（レシピ本体）と `recipe_ingredients`（材料）の2テーブルを作成。
   - インメモリで持っていた2件のレシピをINSERTしてDBに保存。
   - `sqlite3` コマンドでテーブル一覧、スキーマ、中身を確認できることを理解。
   - `JOIN` を使って「レシピとその材料」をまとめて表示するSQLを試行。  
     - `GROUP_CONCAT` による文字列連結。  
     - `JSON_GROUP_ARRAY` によるJSON配列化。  

4. **検索イメージ**
   - 材料テーブルを分けていることで「特定の材料を含むレシピ」や「材料ごとの登場回数集計」が簡単にできることに気づいた。
   - 今後はDB検索版 `/search` を実装し、材料ベースの検索や栄養価追加も視野に入れたい。

### 気づき
- **Pydanticモデルは「型付きの辞書」や「Pythonの構造体」のようなもの**で、バリデーションとJSONシリアライズを兼ね備えている。
- **FastAPIは自動でOpenAPI仕様を生成し、Swagger UIを提供する**ため、APIの仕様確認や試行が非常にスムーズ。
- SQLiteは **標準ライブラリ＋OS付属のツールで即利用可能** で、小規模アプリの学習や試作には非常に便利。
- レシピと材料を別テーブルに分けたことで、検索の柔軟性と拡張性が大幅に増すことを実感。
- 今後の拡張（栄養価計算、材料別ランキング、UI作成）への具体的なイメージが湧いた。

---

